"""Base strategy class for all trading strategies."""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import Any

import pandas as pd
from loguru import logger

from config.strategies import StrategyConfig, TimeFrame
from data.storage.models import OrderSide, SignalSource, SignalType


class StrategyState(str, Enum):
    """Strategy operational state."""

    IDLE = "idle"
    RUNNING = "running"
    PAUSED = "paused"
    STOPPED = "stopped"
    ERROR = "error"


@dataclass
class TradeSignal:
    """Trading signal generated by strategy."""

    timestamp: datetime
    symbol: str
    signal_type: SignalType
    source: SignalSource
    confidence: float  # 0.0 to 1.0

    # Entry/exit prices
    entry_price: Decimal | None = None
    stop_loss: Decimal | None = None
    take_profit: Decimal | None = None

    # Position sizing
    position_size: Decimal | None = None  # As fraction of portfolio
    side: OrderSide | None = None

    # Additional context
    timeframe: TimeFrame | None = None
    indicators: dict[str, Any] = field(default_factory=dict)
    reasoning: str | None = None
    metadata: dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "timestamp": self.timestamp.isoformat(),
            "symbol": self.symbol,
            "signal_type": self.signal_type.value,
            "source": self.source.value,
            "confidence": self.confidence,
            "entry_price": str(self.entry_price) if self.entry_price else None,
            "stop_loss": str(self.stop_loss) if self.stop_loss else None,
            "take_profit": str(self.take_profit) if self.take_profit else None,
            "position_size": str(self.position_size) if self.position_size else None,
            "side": self.side.value if self.side else None,
            "indicators": self.indicators,
            "reasoning": self.reasoning,
        }


@dataclass
class StrategyMetrics:
    """Strategy performance metrics."""

    total_signals: int = 0
    executed_signals: int = 0
    winning_signals: int = 0
    losing_signals: int = 0

    total_pnl: Decimal = Decimal("0")
    avg_win: Decimal = Decimal("0")
    avg_loss: Decimal = Decimal("0")

    win_rate: float = 0.0
    profit_factor: float = 0.0
    sharpe_ratio: float | None = None
    max_drawdown: float = 0.0

    last_signal_time: datetime | None = None
    last_update: datetime = field(default_factory=datetime.utcnow)


class BaseStrategy(ABC):
    """Abstract base class for trading strategies."""

    def __init__(
        self,
        config: StrategyConfig,
        name: str | None = None,
    ):
        """Initialize strategy.

        Args:
            config: Strategy configuration
            name: Optional strategy name override
        """
        self.config = config
        self.name = name or config.name
        self.state = StrategyState.IDLE
        self.metrics = StrategyMetrics()

        # Data storage
        self._candles: dict[str, pd.DataFrame] = {}  # symbol -> DataFrame
        self._current_positions: dict[str, Any] = {}  # symbol -> position
        self._pending_signals: list[TradeSignal] = []

        logger.info(f"Strategy '{self.name}' initialized")

    @property
    def is_running(self) -> bool:
        """Check if strategy is running."""
        return self.state == StrategyState.RUNNING

    @abstractmethod
    def generate_signals(
        self,
        symbol: str,
        candles: pd.DataFrame,
    ) -> list[TradeSignal]:
        """Generate trading signals from market data.

        Args:
            symbol: Trading symbol
            candles: OHLCV DataFrame

        Returns:
            List of trade signals
        """
        pass

    @abstractmethod
    def should_enter(
        self,
        symbol: str,
        candles: pd.DataFrame,
        current_position: Any | None = None,
    ) -> TradeSignal | None:
        """Check if should enter a position.

        Args:
            symbol: Trading symbol
            candles: OHLCV DataFrame
            current_position: Current position if any

        Returns:
            Entry signal or None
        """
        pass

    @abstractmethod
    def should_exit(
        self,
        symbol: str,
        candles: pd.DataFrame,
        position: Any,
    ) -> TradeSignal | None:
        """Check if should exit a position.

        Args:
            symbol: Trading symbol
            candles: OHLCV DataFrame
            position: Current position

        Returns:
            Exit signal or None
        """
        pass

    def update_candles(
        self,
        symbol: str,
        candles: pd.DataFrame,
    ) -> None:
        """Update candle data for a symbol.

        Args:
            symbol: Trading symbol
            candles: New OHLCV DataFrame
        """
        self._candles[symbol] = candles

    def get_candles(self, symbol: str) -> pd.DataFrame | None:
        """Get candle data for a symbol."""
        return self._candles.get(symbol)

    def update_position(
        self,
        symbol: str,
        position: Any | None,
    ) -> None:
        """Update current position for a symbol.

        Args:
            symbol: Trading symbol
            position: Position object or None
        """
        if position is None:
            self._current_positions.pop(symbol, None)
        else:
            self._current_positions[symbol] = position

    def get_position(self, symbol: str) -> Any | None:
        """Get current position for a symbol."""
        return self._current_positions.get(symbol)

    def has_position(self, symbol: str) -> bool:
        """Check if strategy has an open position for symbol."""
        return symbol in self._current_positions

    def start(self) -> None:
        """Start the strategy."""
        if self.state in [StrategyState.IDLE, StrategyState.PAUSED, StrategyState.STOPPED]:
            self.state = StrategyState.RUNNING
            logger.info(f"Strategy '{self.name}' started")

    def pause(self) -> None:
        """Pause the strategy."""
        if self.state == StrategyState.RUNNING:
            self.state = StrategyState.PAUSED
            logger.info(f"Strategy '{self.name}' paused")

    def stop(self) -> None:
        """Stop the strategy."""
        self.state = StrategyState.STOPPED
        logger.info(f"Strategy '{self.name}' stopped")

    def on_candle(
        self,
        symbol: str,
        candle: dict[str, Any],
    ) -> list[TradeSignal]:
        """Process a new candle.

        Args:
            symbol: Trading symbol
            candle: New candle data

        Returns:
            Generated signals
        """
        if not self.is_running:
            return []

        # Update candle data
        if symbol not in self._candles:
            self._candles[symbol] = pd.DataFrame()

        new_row = pd.DataFrame([candle])
        self._candles[symbol] = pd.concat(
            [self._candles[symbol], new_row],
            ignore_index=True,
        )

        # Keep only recent candles
        max_candles = self.config.indicators.bollinger_period * 10
        if len(self._candles[symbol]) > max_candles:
            self._candles[symbol] = self._candles[symbol].tail(max_candles)

        # Generate signals
        signals = self.generate_signals(symbol, self._candles[symbol])

        # Update metrics
        self.metrics.total_signals += len(signals)
        if signals:
            self.metrics.last_signal_time = datetime.utcnow()

        return signals

    def on_trade(
        self,
        symbol: str,
        trade: dict[str, Any],
    ) -> None:
        """Process a completed trade.

        Args:
            symbol: Trading symbol
            trade: Trade data
        """
        pnl = Decimal(str(trade.get("pnl", 0)))

        self.metrics.executed_signals += 1

        if pnl > 0:
            self.metrics.winning_signals += 1
            # Update average win
            total_wins = self.metrics.avg_win * (self.metrics.winning_signals - 1) + pnl
            self.metrics.avg_win = total_wins / self.metrics.winning_signals
        elif pnl < 0:
            self.metrics.losing_signals += 1
            # Update average loss
            total_losses = self.metrics.avg_loss * (self.metrics.losing_signals - 1) + abs(pnl)
            self.metrics.avg_loss = total_losses / self.metrics.losing_signals

        self.metrics.total_pnl += pnl

        # Update win rate
        if self.metrics.executed_signals > 0:
            self.metrics.win_rate = self.metrics.winning_signals / self.metrics.executed_signals

        # Update profit factor
        if self.metrics.avg_loss > 0:
            avg_win_decimal = float(self.metrics.avg_win)
            avg_loss_decimal = float(self.metrics.avg_loss)
            if self.metrics.losing_signals > 0:
                self.metrics.profit_factor = (
                    (self.metrics.winning_signals * avg_win_decimal) /
                    (self.metrics.losing_signals * avg_loss_decimal)
                )

        self.metrics.last_update = datetime.utcnow()

    def calculate_position_size(
        self,
        symbol: str,
        signal: TradeSignal,
        portfolio_value: Decimal,
    ) -> Decimal:
        """Calculate position size for a signal.

        Args:
            symbol: Trading symbol
            signal: Trade signal
            portfolio_value: Total portfolio value

        Returns:
            Position size in quote currency
        """
        # Base position size from config
        base_size = self.config.max_position_per_symbol

        # Adjust for signal confidence
        confidence_multiplier = 0.5 + signal.confidence * 0.5  # 0.5 to 1.0

        # Apply position size
        position_value = portfolio_value * Decimal(str(base_size * confidence_multiplier))

        return position_value

    def calculate_stop_loss(
        self,
        entry_price: Decimal,
        side: OrderSide,
        atr: Decimal | None = None,
    ) -> Decimal:
        """Calculate stop loss price.

        Args:
            entry_price: Entry price
            side: Trade side
            atr: Average True Range (optional)

        Returns:
            Stop loss price
        """
        if atr and self.config.indicators.atr_period > 0:
            # ATR-based stop loss
            multiplier = Decimal("2.0")  # 2x ATR
            atr_stop = entry_price - (atr * multiplier) if side == OrderSide.BUY else entry_price + (atr * multiplier)
            return atr_stop
        else:
            # Fixed percentage stop loss
            stop_pct = Decimal(str(self.config.rl_config.transaction_cost_penalty * 10))  # e.g., 2%
            if side == OrderSide.BUY:
                return entry_price * (1 - stop_pct)
            else:
                return entry_price * (1 + stop_pct)

    def calculate_take_profit(
        self,
        entry_price: Decimal,
        stop_loss: Decimal,
        side: OrderSide,
        risk_reward_ratio: float = 2.0,
    ) -> Decimal:
        """Calculate take profit price.

        Args:
            entry_price: Entry price
            stop_loss: Stop loss price
            side: Trade side
            risk_reward_ratio: Desired risk/reward ratio

        Returns:
            Take profit price
        """
        risk = abs(entry_price - stop_loss)
        target_profit = risk * Decimal(str(risk_reward_ratio))

        if side == OrderSide.BUY:
            return entry_price + target_profit
        else:
            return entry_price - target_profit

    def get_status(self) -> dict[str, Any]:
        """Get strategy status."""
        return {
            "name": self.name,
            "state": self.state.value,
            "symbols": list(self._candles.keys()),
            "positions": list(self._current_positions.keys()),
            "metrics": {
                "total_signals": self.metrics.total_signals,
                "executed_signals": self.metrics.executed_signals,
                "win_rate": self.metrics.win_rate,
                "profit_factor": self.metrics.profit_factor,
                "total_pnl": str(self.metrics.total_pnl),
                "max_drawdown": self.metrics.max_drawdown,
            },
            "config": {
                "type": self.config.strategy_type.value,
                "timeframe": self.config.primary_timeframe.value,
            },
        }

    def reset(self) -> None:
        """Reset strategy state."""
        self._candles.clear()
        self._current_positions.clear()
        self._pending_signals.clear()
        self.metrics = StrategyMetrics()
        self.state = StrategyState.IDLE
        logger.info(f"Strategy '{self.name}' reset")
